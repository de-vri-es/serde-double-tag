use proc_macro2::TokenStream;
use quote::quote;
use syn::spanned::Spanned;

use crate::util;

/// Generate code that implement the serde `Serialize` trait for an enum using the double-tag format.
pub fn impl_deserialize_enum(crate_name: &syn::Path, tokens: TokenStream) -> TokenStream {
	let item = match util::parse_enum_item(tokens) {
		Ok(x) => x,
		Err(e) => return e.into_compile_error(),
	};

	let enum_name = &item.ident;
	let serde: syn::Path = syn::parse_quote!(#crate_name::internal__::serde);

	let (_impl_generics, type_generics, _where_clause) = item.generics.split_for_impl();
	let (de_generics, de_lifetime, error) = util::add_lifetime(&item.generics, "de");
	let where_clause = make_where_clause(crate_name, &item, &de_lifetime);
	let (impl_generics, _type_generics, _where_clause) = de_generics.split_for_impl();

	quote! {
		#error
		impl #impl_generics  #serde::Deserialize<#de_lifetime> for #enum_name #type_generics #where_clause {
			fn deserialize<D: #serde::Deserializer<#de_lifetime>>(deserializer: D) -> ::core::result::Result<Self, D::Error> {
				struct Visitor #type_generics {
					_phantom: ::core::marker::PhantomData<fn() -> #enum_name #type_generics>,
				};
				impl #impl_generics #serde::de::Visitor<#de_lifetime> for Visitor #type_generics #where_clause {
					type Value = #enum_name #type_generics;

					fn expecting(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
						f.write_str("map with `type` and data fields")
					}

					fn visit_map<A: #serde::de::MapAccess<#de_lifetime>>(self, map: A) -> ::core::result::Result<Self::Value, A::Error> {
						map.next_entry()?;
						todo!();
					}
				}
				deserializer.deserialize_map(Visitor {
					_phantom: ::core::marker::PhantomData
				})
			}
		}
	}
}

fn make_tag_enum(crate_name: &syn::Path, item: &syn::ItemEnum) -> TokenStream {
	let serde: syn::Path = syn::parse_quote!(#crate_name::internal__::serde);

	let variant_name: Vec<_> = item.variants.iter().map(|x| &x.ident).collect();
	let tag_value: Vec<_> = item.variants.iter().map(|x| util::to_snake_case(&x.ident.to_string())).collect();

	let expecting = match tag_value.as_slice() {
		[] => String::from("nothing"),
		[tag] => format!("the string {tag:?}"),
		values => {
			let mut expecting = String::from("one of ");
			for (i, value) in values.iter().enumerate() {
				if i == 0 {
					write!(expecting, "{value:?}").unwrap();
				} else if i == values.len() - 1 {
					write!(expecting, " or {value:?}").unwrap();
				} else {
					write!(expecting, ", {value:?}").unwrap();
				}
			}
		}
	};

	let mut expecting = String::from("one of "
	quote! {
		enum Tag {
			#(#variant_name,)*
		}

		impl<'de> #serde::Deserialize<'de> for Tag {
			fn deserialize<D: #serde::Deserializer<'de>>(deserializer: D) -> ::core::result::Result<Self, D::Error> {
				struct Visitor;

				impl<'de> #serde::de::Visit<'de> for Visitor {
					type Value = Tag;

					fn expecting(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
						f.write_str(#expecting)
					}
				}
			}
		}
	}
}

fn make_where_clause(crate_name: &syn::Path, item: &syn::ItemEnum, de_lifetime: &syn::Lifetime) -> Option<syn::WhereClause> {
	let serde: syn::Path = syn::parse_quote!(#crate_name::internal__::serde);

	let mut predicates = Vec::<syn::WherePredicate>::new();
	for variant in &item.variants {
		for field in &variant.fields {
			if util::type_uses_generic(&field.ty, &item.generics) {
				let ty = &field.ty;
				predicates.push(syn::parse_quote! {
					#ty: #serde::Deserialize<#de_lifetime>
				})
			}
		}
	}

	match &item.generics.where_clause {
		Some(clause) => {
			let mut clause = clause.clone();
			clause.predicates.extend(predicates);
			Some(clause)
		},
		None => {
			if predicates.is_empty() {
				None
			} else {
				Some(syn::parse_quote!(where #(#predicates,)*))
			}
		}
	}
}
